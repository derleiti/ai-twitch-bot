#!/usr/bin/env python3
# youtube_chat.py - YouTube-Chat-Integration für Zephyr-Bot

import os
import time
import threading
import requests
import json
from datetime import datetime
from dotenv import load_dotenv

# Lade Umgebungsvariablen
load_dotenv()

class YouTubeChatClient:
    def __init__(self, api_key, channel_id, bot_name, message_handler=None, log_func=None):
        self.api_key = api_key
        self.channel_id = channel_id
        self.bot_name = bot_name
        self.message_handler = message_handler
        self.log_func = log_func or print
        
        self.running = False
        self.live_chat_id = None
        self.next_page_token = None
        self.known_message_ids = set()
        self.poll_interval = 5  # Sekunden zwischen API-Anfragen
        self.last_poll_time = 0
        
        # YouTube API Endpoints
        self.search_url = "https://www.googleapis.com/youtube/v3/search"
        self.videos_url = "https://www.googleapis.com/youtube/v3/videos"
        self.live_chat_url = "https://www.googleapis.com/youtube/v3/liveChat/messages"
        
    def log(self, message, level=1):
        """Loggt eine Nachricht"""
        if self.log_func:
            self.log_func(f"[YouTube] {message}", level)
        else:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"[{timestamp}] [YouTube] {message}")
    
    def find_live_stream(self):
        """Findet den aktuellen Live-Stream des Kanals"""
        try:
            params = {
                'part': 'id',
                'channelId': self.channel_id,
                'type': 'video',
                'eventType': 'live',
                'key': self.api_key,
                'maxResults': 1
            }
            
            response = requests.get(self.search_url, params=params, timeout=10)
            
            if response.status_code != 200:
                self.log(f"Fehler bei Live-Stream-Suche: HTTP {response.status_code}")
                return None
                
            data = response.json()
            
            if not data.get('items'):
                self.log("Kein aktiver Live-Stream gefunden")
                return None
                
            video_id = data['items'][0]['id']['videoId']
            self.log(f"Live-Stream gefunden: {video_id}")
            
            return self.get_live_chat_id(video_id)
            
        except Exception as e:
            self.log(f"Fehler beim Finden des Live-Streams: {e}")
            return None
    
    def get_live_chat_id(self, video_id):
        """Holt die Live-Chat-ID für ein Video"""
        try:
            params = {
                'part': 'liveStreamingDetails',
                'id': video_id,
                'key': self.api_key
            }
            
            response = requests.get(self.videos_url, params=params, timeout=10)
            
            if response.status_code != 200:
                self.log(f"Fehler beim Abrufen der Video-Details: HTTP {response.status_code}")
                return None
                
            data = response.json()
            
            if not data.get('items'):
                self.log("Video-Details nicht gefunden")
                return None
                
            live_details = data['items'][0].get('liveStreamingDetails', {})
            chat_id = live_details.get('activeLiveChatId')
            
            if chat_id:
                self.log(f"Live-Chat-ID gefunden: {chat_id}")
                return chat_id
            else:
                self.log("Keine Live-Chat-ID verfügbar")
                return None
                
        except Exception as e:
            self.log(f"Fehler beim Abrufen der Live-Chat-ID: {e}")
            return None
    
    def get_chat_messages(self):
        """Holt neue Chat-Nachrichten"""
        if not self.live_chat_id:
            return []
            
        try:
            params = {
                'liveChatId': self.live_chat_id,
                'part': 'id,snippet,authorDetails',
                'key': self.api_key,
                'maxResults': 200
            }
            
            if self.next_page_token:
                params['pageToken'] = self.next_page_token
                
            response = requests.get(self.live_chat_url, params=params, timeout=10)
            
            if response.status_code != 200:
                self.log(f"Fehler beim Abrufen der Chat-Nachrichten: HTTP {response.status_code}")
                return []
                
            data = response.json()
            
            # Update page token für nächste Anfrage
            self.next_page_token = data.get('nextPageToken')
            
            # Polling-Intervall aus API-Response verwenden
            polling_interval = data.get('pollingIntervalMillis', 5000) / 1000
            self.poll_interval = max(polling_interval, 2)  # Minimum 2 Sekunden
            
            messages = []
            for item in data.get('items', []):
                message_id = item['id']
                
                # Überspringe bereits verarbeitete Nachrichten
                if message_id in self.known_message_ids:
                    continue
                    
                self.known_message_ids.add(message_id)
                
                # Cleanup alter Message-IDs (behalte nur die letzten 1000)
                if len(self.known_message_ids) > 1000:
                    # Entferne die ältesten 200 IDs
                    old_ids = list(self.known_message_ids)[:200]
                    for old_id in old_ids:
                        self.known_message_ids.discard(old_id)
                
                snippet = item.get('snippet', {})
                author_details = item.get('authorDetails', {})
                
                # Extrahiere Nachrichtendaten
                username = author_details.get('displayName', 'Unknown')
                message_text = snippet.get('textMessageDetails', {}).get('messageText', '')
                
                # Überspringe eigene Nachrichten (falls der Bot irgendwie schreibt)
                if username.lower() == self.bot_name.lower():
                    self.log(f"Eigene Nachricht übersprungen: {message_text}", level=2)
                    continue
                
                # Überspringe leere Nachrichten
                if not message_text.strip():
                    continue
                
                messages.append({
                    'id': message_id,
                    'username': username,
                    'message': message_text,
                    'timestamp': snippet.get('publishedAt'),
                    'platform': 'youtube'
                })
                
            return messages
            
        except Exception as e:
            self.log(f"Fehler beim Abrufen der Chat-Nachrichten: {e}")
            return []
    
    def connect(self):
        """Verbindet zum YouTube Live-Chat"""
        self.log("Suche nach aktivem Live-Stream...")
        self.live_chat_id = self.find_live_stream()
        
        if not self.live_chat_id:
            self.log("Kein aktiver Live-Stream gefunden oder Chat nicht verfügbar")
            return False
            
        self.log(f"Verbunden mit YouTube Live-Chat: {self.live_chat_id}")
        self.running = True
        return True
    
    def disconnect(self):
        """Trennt die Verbindung"""
        self.running = False
        self.live_chat_id = None
        self.next_page_token = None
        self.log("YouTube-Chat-Verbindung getrennt")
    
    def start_polling(self):
        """Startet das Polling für neue Nachrichten"""
        if not self.running:
            self.log("Chat-Client ist nicht verbunden")
            return
            
        self.log("Starte Chat-Nachrichtenüberwachung...")
        
        while self.running:
            try:
                current_time = time.time()
                
                # Warte auf nächstes Poll-Intervall
                if current_time - self.last_poll_time < self.poll_interval:
                    time.sleep(0.5)
                    continue
                
                self.last_poll_time = current_time
                
                # Hole neue Nachrichten
                messages = self.get_chat_messages()
                
                # Verarbeite neue Nachrichten
                for message in messages:
                    try:
                        if self.message_handler:
                            self.message_handler(message['username'], message['message'], 'youtube')
                        else:
                            self.log(f"[{message['username']}]: {message['message']}")
                    except Exception as e:
                        self.log(f"Fehler bei Nachrichtenverarbeitung: {e}")
                
                # Kurze Pause zwischen Polls
                time.sleep(1)
                
            except Exception as e:
                self.log(f"Fehler im Polling-Loop: {e}")
                time.sleep(5)  # Längere Pause bei Fehlern
    
    def send_message(self, message):
        """
        WICHTIG: Diese Funktion ist NICHT implementiert!
        YouTube Live Chat API erlaubt es nicht, Nachrichten über API-Key zu senden.
        Dafür wäre OAuth und spezielle Berechtigung nötig.
        
        Der Bot kann nur LESEN, nicht SCHREIBEN.
        """
        self.log(f"WARNUNG: Kann Nachricht nicht senden (YouTube API-Beschränkung): {message}")
        return False


# Standalone-Test
if __name__ == "__main__":
    def test_message_handler(username, message, platform):
        print(f"[{platform.upper()}] {username}: {message}")
    
    api_key = os.getenv("YOUTUBE_API_KEY")
    channel_id = os.getenv("YOUTUBE_CHANNEL_ID")
    bot_name = os.getenv("YOUTUBE_BOT_NAME", "zephyr")
    
    if not api_key or not channel_id:
        print("FEHLER: YOUTUBE_API_KEY und YOUTUBE_CHANNEL_ID müssen in .env gesetzt sein")
        exit(1)
    
    client = YouTubeChatClient(api_key, channel_id, bot_name, test_message_handler)
    
    try:
        if client.connect():
            client.start_polling()
        else:
            print("Verbindung fehlgeschlagen")
    except KeyboardInterrupt:
        print("\nBeendet durch Benutzer")
    finally:
        client.disconnect()
