# Datei: watch_screenshots.py
#!/usr/bin/env python3
import time
import os
import sys
import tempfile
import hashlib
from datetime import datetime
from analyze_and_respond import analyze_and_comment

# Dynamische Pfadbestimmung
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
if not os.path.exists(BASE_DIR):
    BASE_DIR = os.path.expanduser("~/zephyr")

SCREENSHOT_DIR = os.path.join(BASE_DIR, "screenshots")
SEEN_FILES_CACHE = os.path.join(tempfile.gettempdir(), "zephyr_seen_files.txt")
MAX_CACHE_SIZE = 1000  # Maximale Anzahl von Dateien im Cache
MAX_SCREENSHOTS = 100  # NEU: Max. 100 Dateien behalten

def send_message_to_platforms(message, exclude_platform=None):
    """Sendet eine Nachricht an alle verf√ºgbaren Plattformen - ERWEITERT mit Message Dispatcher"""
    success = False
    
    # PRIORIT√ÑT 1: Versuche Message Dispatcher
    try:
        from message_dispatcher import queue_message
        queue_message("vision", "Screenshot-Watcher", message)
        print(f"‚úÖ [DISPATCHER] Bildkommentar an Message Queue weitergeleitet: {message[:50]}...")
        return True
    except ImportError:
        print("‚ö†Ô∏è Message Dispatcher nicht verf√ºgbar, verwende Fallback...")
    except Exception as e:
        print(f"‚ùå Fehler bei Message Dispatcher: {e}")
    
    # PRIORIT√ÑT 2: Versuche Import der Multi-Platform-Bot-Funktionen
    try:
        sys.path.append(BASE_DIR)
        from multi_platform_bot import send_message_to_platforms as bot_send_platforms
        return bot_send_platforms(message, exclude_platform)
    except ImportError:
        print("‚ö†Ô∏è Multi-Platform-Bot Funktionen nicht verf√ºgbar...")
    except Exception as e:
        print(f"‚ùå Fehler bei Multi-Platform-Bot: {e}")
    
    # PRIORIT√ÑT 3: Fallback: Versuche alte Twitch-Bot-Funktion
    try:
        from twitch_ollama_bot import send_message as twitch_send_message
        return twitch_send_message(message)
    except ImportError:
        print("‚ö†Ô∏è Twitch-Bot nicht verf√ºgbar...")
    except Exception as e:
        print(f"‚ùå Fehler bei Twitch-Bot: {e}")
    
    # PRIORIT√ÑT 4: Letzter Fallback: Nur ausgeben
    platform_prefix = "üì∏ [AUTO] " if not exclude_platform else f"üì∏ [{exclude_platform.upper()}] "
    print(f"‚ö† Konnte Nachricht nicht senden - Ausgabe: {platform_prefix}{message}")
    return False

def load_seen_files():
    seen_files = set()
    try:
        if os.path.exists(SEEN_FILES_CACHE):
            with open(SEEN_FILES_CACHE, 'r') as f:
                for line in f:
                    seen_files.add(line.strip())
    except Exception as e:
        print(f"‚ö† Fehler beim Laden des Cache: {e}")
    return seen_files

def save_seen_files(seen_files):
    try:
        with open(SEEN_FILES_CACHE, 'w') as f:
            for file_hash in list(seen_files)[-MAX_CACHE_SIZE:]:
                f.write(f"{file_hash}\n")
    except Exception as e:
        print(f"‚ö† Fehler beim Speichern des Cache: {e}")

def get_file_hash(file_path):
    try:
        mtime = os.path.getmtime(file_path)
        file_size = os.path.getsize(file_path)
        hash_str = f"{file_path}_{mtime}_{file_size}"
        return hashlib.md5(hash_str.encode()).hexdigest()
    except Exception as e:
        print(f"‚ö† Fehler beim Hash-Erstellen f√ºr {file_path}: {e}")
        return hashlib.md5(file_path.encode()).hexdigest()

def cleanup_screenshot_dir(max_files=MAX_SCREENSHOTS):
    try:
        files = [os.path.join(SCREENSHOT_DIR, f)
                 for f in os.listdir(SCREENSHOT_DIR)
                 if f.lower().endswith(('.jpg', '.jpeg', '.png'))]

        if len(files) <= max_files:
            return

        files.sort(key=os.path.getmtime)
        files_to_delete = files[:-max_files]

        for f in files_to_delete:
            try:
                os.remove(f)
                print(f"üóëÔ∏è Alte Datei gel√∂scht: {os.path.basename(f)}")
            except Exception as e:
                print(f"‚ö† Fehler beim L√∂schen {f}: {e}")
    except Exception as e:
        print(f"‚ö† Fehler beim Bereinigen: {e}")

def handle_new_file(file_path):
    """ERWEITERTE Funktion f√ºr neue Dateien mit Message Dispatcher Integration"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] üì∏ Neues Bild erkannt: {file_path}")
    
    try:
        # Analysiere das Bild ohne Platform-Hint (f√ºr alle Plattformen)
        result = analyze_and_comment(file_path)
        if result:
            # Die analyze_and_comment Funktion sendet bereits √ºber den Message Dispatcher
            # Falls sie das nicht kann, hat sie bereits Fallback-Methoden verwendet
            print(f"[{timestamp}] ‚úÖ Bildanalyse und Weiterleitung erfolgreich")
            return True
        else:
            print(f"[{timestamp}] ‚ö† Analyse oder Antwort fehlgeschlagen.")
            
            # Fallback: Direkte Sendung einer Standard-Nachricht
            fallback_message = "üì∏ Neuer Screenshot erkannt, aber Analyse fehlgeschlagen."
            success = send_message_to_platforms(fallback_message)
            return success
            
    except Exception as e:
        print(f"[{timestamp}] ‚ùå Fehler bei Bildverarbeitung: {e}")
        
        # Fallback: Sende Fehlermeldung
        try:
            error_message = "üì∏ Screenshot erkannt, aber Verarbeitung fehlgeschlagen."
            send_message_to_platforms(error_message)
        except:
            pass
    
    return False

def main():
    """ERWEITERTE Hauptfunktion mit Message Dispatcher Integration"""
    print(f"üëÅ Multi-Platform Screenshot-Watcher startet - √úberwache: {SCREENSHOT_DIR}")
    print("üîó Integriert mit Message Dispatcher f√ºr optimale Multi-Platform-Unterst√ºtzung")
    
    if not os.path.exists(SCREENSHOT_DIR):
        os.makedirs(SCREENSHOT_DIR, exist_ok=True)
        print(f"üìÅ Verzeichnis erstellt: {SCREENSHOT_DIR}")
    
    seen_files = load_seen_files()
    print(f"üîÑ {len(seen_files)} bereits gesehene Dateien geladen.")
    
    last_save_time = time.time()
    
    # Test der Message Dispatcher Verbindung
    try:
        from message_dispatcher import get_dispatcher_stats
        stats = get_dispatcher_stats()
        print(f"üìä Message Dispatcher Status: {len(stats.get('platforms_registered', []))} Plattformen registriert")
    except ImportError:
        print("‚ö†Ô∏è Message Dispatcher nicht geladen - verwende Fallback-Methoden")
    
    try:
        while True:
            current_time = time.time()
            
            # Speichere Cache regelm√§√üig
            if current_time - last_save_time > 300:  # Alle 5 Minuten
                save_seen_files(seen_files)
                last_save_time = current_time
            
            try:
                # Pr√ºfe die letzten 10 Dateien f√ºr neue Screenshots
                files = sorted([f for f in os.listdir(SCREENSHOT_DIR) 
                                if f.lower().endswith(('.jpg', '.jpeg', '.png'))])
                
                for f in files[-10:]:  # Nur die neuesten 10 Dateien pr√ºfen
                    full_path = os.path.join(SCREENSHOT_DIR, f)
                    file_hash = get_file_hash(full_path)
                    
                    if file_hash not in seen_files:
                        seen_files.add(file_hash)
                        
                        # Verarbeite neues Bild
                        if handle_new_file(full_path):
                            cleanup_screenshot_dir()  # Auto-Cleanup direkt danach
                            save_seen_files(seen_files)  # Speichere nach erfolgreicher Verarbeitung
                
            except Exception as e:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                print(f"[{timestamp}] ‚ùå Fehler beim Durchsuchen des Verzeichnisses: {e}")
            
            # Warte 3 Sekunden vor n√§chster Pr√ºfung
            time.sleep(3)
            
    except KeyboardInterrupt:
        print("\n‚õî Beendet durch Benutzer.")
    except Exception as e:
        print(f"‚ùå Unerwarteter Fehler: {e}")
    finally:
        save_seen_files(seen_files)
        print("üíæ Cache gespeichert. Multi-Platform Screenshot-Watcher wird beendet.")

if __name__ == "__main__":
    main()
